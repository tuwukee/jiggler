#!/usr/bin/env ruby

# command: bundle exec bin/sidekiqload

require "sidekiq"

Sidekiq.redis { |c| c.flushall }

class LoadJob
  include Sidekiq::Job
  sidekiq_options retry: 1

  def fib(n)
    if n <= 1
      1
    else
      (fib(n-1) + fib(n-2))
    end
  end

  def perform(idx)
  end
end

def get_rss(pid)
  `ps -o rss= -p #{pid}`.chomp.to_i
end

# when trying to upload 1_000_000 at once
# ruby_connection/buffered_io.rb:140:in `block in fill_buffer': RedisClient::ReadTimeoutError (RedisClient::ReadTimeoutError)
iter = 10
pre_count = 100_000
count = iter * pre_count

Sidekiq.logger.error "Uploading #{count} jobs..."
iter.times do |i|
  arr = Array.new(pre_count) { |idx| [idx] }
  Sidekiq::Client.push_bulk("class" => LoadJob, "args" => arr)
end
Sidekiq.logger.error "Created #{count} jobs"

real_start = Process.clock_gettime(Process::CLOCK_MONOTONIC)
p2 = fork do
  require "sidekiq/cli"

  Sidekiq.configure_server do |config|
    config.concurrency = 10
    config.queues = %w[default]
    config.logger.level = Logger::WARN
    config.average_scheduled_poll_interval = 5
  end

  begin
    cli = Sidekiq::CLI.instance
    cli.parse ["-r", "tmp/temp.rb"] # require an empty file to pass validation
  
    cli.run(boot_app: false)
  rescue => e
    Sidekiq.logger.error(e)
    exit 1
  end
end

def jobs_count
  Sidekiq.redis do |conn|
    conn.llen "queue:default"
  end
end

start = Time.now

total = jobs_count
Sidekiq.logger.error("RSS: #{get_rss(p2)} Pending: #{total}")
loop do
  sleep 2.0
  total = jobs_count
  Sidekiq.logger.error("RSS: #{get_rss(p2)} Pending: #{total}")
  if total == 0
    Sidekiq.logger.error("RSS: #{get_rss(p2)} Pending: #{total}")
    Sidekiq.logger.error("Done, #{count} jobs in #{Time.now - start} sec")
    break
  end
end
Process.kill("INT", p2)
Process.wait(p2)
Sidekiq.logger.error("Real time is: #{Process.clock_gettime(Process::CLOCK_MONOTONIC) - real_start}")
