#!/usr/bin/env ruby

# command: bundle exec bin/jigglerload
# bundle exec bin/jiggler -v -r ./spec/fixtures/jobs

# require_relative '../lib/jiggler'
# require_relative '../lib/jiggler/cli'

# require 'debug'


# require 'jiggler'
# require 'jiggler/cli'

# require 'ruby-prof'
# require 'heap-profiler'

require_relative '../lib/jiggler/support/component'
require_relative '../lib/jiggler/scheduled/enqueuer'
require_relative '../lib/jiggler/scheduled/poller'
require_relative '../lib/jiggler/stats/collection'
require_relative '../lib/jiggler/stats/monitor'

require_relative '../lib/jiggler/errors'
require_relative '../lib/jiggler/redis_store'
require_relative '../lib/jiggler/job'
require_relative '../lib/jiggler/config'
require_relative '../lib/jiggler/cleaner'
require_relative '../lib/jiggler/retrier'
require_relative '../lib/jiggler/launcher'
require_relative '../lib/jiggler/manager'
require_relative '../lib/jiggler/worker'
require_relative '../lib/jiggler/summary'
require_relative '../lib/jiggler/version'

require_relative '../lib/jiggler/core'
require_relative '../lib/jiggler/cli'

Jiggler.configure_server do |config|
  config[:poll_interval] = 2
  config[:concurrency] = 20
  # config[:poller_enabled] = false
  # config[:stats_enabled] = false
  config.logger.level = Logger::WARN
end

Jiggler.configure_client do |config|
  config[:redis_mode] = :async
end

class LoadJob
  include Jiggler::Job
  job_options retries: 1, async: true

  def fib(n)
    if n <= 1
      1
    else
      (fib(n-1) + fib(n-2))
    end
  end

  def perform(idx, ts = nil)
    # puts('job is performing') if rand(1000).zero?
    start = Process.clock_gettime(Process::CLOCK_MONOTONIC)
    # puts "started task\n"
    sleep 0.01
    fib(33)
    sleep 0.01
    fib(20)
    sleep 0.01
    # puts "ended task #{Process.clock_gettime(Process::CLOCK_MONOTONIC) - start}\n"

    puts("#{Time.now.to_f - ts}\n") if !ts.nil?
  end
end

Jiggler.config.cleaner.prune_all

cli = Jiggler::CLI.instance

iter = 1
count = 300
Jiggler.logger.warn "Uploading #{count * iter} jobs..."
iter.times do |i|
  arr = Array.new(count) { |idx| [idx] }
  LoadJob.enqueue_bulk(arr)
end
Jiggler.logger.warn "Created #{count * iter} jobs"

def Process.rss
  `ps -o rss= -p #{Process.pid}`.chomp.to_i
end

def jobs_count
  Jiggler.redis do |conn|
    conn.call 'LLEN', 'jiggler:list:default'
  end
end

start = Time.now
Monitoring = Thread.new do
  total = jobs_count
  Jiggler.logger.warn("RSS: #{Process.rss} Pending: #{total}")
  loop do
    sleep 2.0
    total = jobs_count
    # Jiggler.logger.warn("RSS: #{Process.rss} Pending: #{total}")
    if total == 0
      Jiggler.logger.warn("RSS: #{Process.rss} Pending: #{total}")
      Jiggler.logger.warn("Done, #{iter * count} jobs in #{Time.now - start} sec")
      # Jiggler.logger.warn("Latency for three jobs")

      # LoadJob.enqueue(1, Time.now.to_f)
      # LoadJob.enqueue(2, Time.now.to_f)
      # LoadJob.enqueue(3, Time.now.to_f)

      sleep 0.2
      break
    end
  end
  Process.kill("INT", Process.pid)
end

def start_jiggler(cli)
  begin
    cli.parse

    cli.config.logger.warn("Jiggler is starting for LOAD TEST ✯⸜(*❛‿❛)⸝✯")
    cli.config.logger.warn("Jiggler version=#{Jiggler::VERSION} pid=#{Process.pid} concurrency=#{cli.config[:concurrency]} queues=#{cli.config[:queues].join(',')}")
    cli.start
  rescue => e
    warn e.message
    warn e.backtrace.join("\n")
    # exit 1
  end
end

start_jiggler(cli)

# async loop: 79624 (23:06:45) -> 79900 (23:07:46) -> 80116 (23:11:45)
# poller (poll int 5): 
# 80088 (23:12:48) -> 80376 (1min 23:13:13) -> 83592 (5min 23:17:43)
# poller (poll int 5) & manager (concurrency 2): 
# 82384 (23:19:35) -> 90388 (1min 23:20:37) -> 92016 (5min 23:24:16)
#
# Async do
#  loop do
#    sleep(2)
#    Jiggler.logger.warn("looping...")
#  end
# end

# -> RubyProf
# RubyProf.exclude_threads = [Monitoring]
# RubyProf.measure_mode = RubyProf::ALLOCATIONS
# result = RubyProf.profile(:track_allocations => true) do
#   start_jiggler(cli)
#   Jiggler.logger.warn("Ruby-prof is wrapping up...")
# end
# printer = RubyProf::GraphHtmlPrinter.new(result)
# printer.print(File.new("tmp/rubyprof.html", "w"), min_percent: 10)

# -> HeapProfiler
# heap-profiler tmp/allocated.heap
# HeapProfiler.report("tmp") do
#   start_jiggler(cli)
# end
